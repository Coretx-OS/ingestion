# Chrome Extension Boilerplate - Development Guide

A production-ready Chrome Extension template using **Manifest V3**, **TypeScript**, **React**, **Vite**, and **Tailwind CSS**. Created by Ken Kai as a starting point for building modern Chrome extensions with full type safety, hot module reloading, and clean architectural patterns.

**Repository:** https://github.com/robert-cousins/kens-chrome-extension

## Project Structure

```
/home/robert/projects/kens-chrome-extension/
├── src/                            # Source code
│   ├── background/
│   │   └── index.ts                # Service worker - handles extension lifecycle, message routing, Chrome APIs
│   ├── content/
│   │   ├── index.ts                # Content script - runs on all web pages, can modify DOM
│   │   └── content.css             # Content script isolated styles
│   ├── lib/
│   │   ├── index.ts                # Library exports
│   │   ├── storage.ts              # Type-safe Chrome storage wrapper with TypeScript interfaces
│   │   └── messaging.ts            # Type-safe message passing between background/popup/content
│   ├── popup/
│   │   ├── main.tsx                # React entry point for popup
│   │   ├── Popup.tsx               # Popup UI component (toolbar icon click)
│   │   ├── popup.html              # Popup HTML shell
│   │   └── popup.css               # Popup styles
│   ├── options/
│   │   ├── main.tsx                # React entry point for options
│   │   ├── Options.tsx             # Full-page settings UI component
│   │   ├── options.html            # Options page HTML shell
│   │   └── options.css             # Options page styles
│   └── vite-env.d.ts               # Vite environment types
├── public/
│   └── icons/
│       ├── icon-16.png             # 16x16 toolbar icon
│       ├── icon-32.png             # 32x32 notification icon
│       ├── icon-48.png             # 48x48 management page icon
│       └── icon-128.png            # 128x128 web store icon
├── dist/                           # Build output (generated by Vite)
├── node_modules/                   # npm dependencies
├── CLAUDE.md                       # This file - development guide
├── README.md                       # Project documentation
├── manifest.json                   # Chrome extension manifest (MV3)
├── package.json                    # npm configuration and scripts
├── package-lock.json               # npm lock file
├── vite.config.ts                  # Vite build configuration with @crxjs plugin
├── tsconfig.json                   # TypeScript configuration (strict mode)
├── tsconfig.node.json              # TypeScript config for Node tools
├── eslint.config.js                # ESLint configuration (flat config)
├── tailwind.config.js              # Tailwind CSS configuration
└── postcss.config.js               # PostCSS configuration
```

## Tech Stack

- **TypeScript** 5.7.2 - Strict type checking
- **React** 18.3.1 - UI components
- **Vite** 6.0.3 - Build tool with HMR
- **@crxjs/vite-plugin** 2.0.0-beta.28 - Chrome MV3 support
- **Tailwind CSS** 3.4.16 - Utility-first styling
- **ESLint** 9.16.0 - Code quality
- **Chrome Types** 0.0.287 - Full Chrome API types

## Organization Rules

**Keep code organized and modularized:**
- **Background logic** → `src/background/index.ts` - message handlers, lifecycle events, Chrome APIs
- **Content scripts** → `src/content/index.ts` - DOM manipulation, page interaction
- **Popup UI** → `src/popup/Popup.tsx` - React components with Tailwind
- **Options UI** → `src/options/Options.tsx` - React components for settings
- **Shared utilities** → `src/lib/` - storage, messaging, reusable functions
- **Type definitions** → Co-located with usage or in `src/lib/` interfaces
- **Tests** → Next to the code they test (when added)

**Modularity principles:**
- Single responsibility per file
- Clear, descriptive file names (PascalCase for React components, camelCase for utilities)
- Group related functionality together
- Avoid monolithic files
- Use TypeScript interfaces for all message types and storage schemas

## Code Quality - Zero Tolerance

After editing ANY file, run:

```bash
npm run lint       # Fix ALL ESLint errors/warnings
npm run typecheck  # Fix ALL TypeScript type errors
```

Fix ALL errors/warnings before continuing. No exceptions.

If changes require extension reload:
1. Go to `chrome://extensions/`
2. Click refresh icon on your extension
3. Test functionality in browser
4. Check console for runtime errors (background: click "Service Worker" link; popup: right-click icon → Inspect popup; content: page DevTools)

**Development workflow:**
```bash
npm run dev        # Start development with HMR (Vite watch mode)
npm run build      # Production build (runs tsc + vite build)
```

## Architecture Overview

### Communication Flow
```
┌─────────┐     messages      ┌────────────┐     messages      ┌─────────┐
│  Popup  │ ←───────────────→ │ Background │ ←───────────────→ │ Content │
│ (React) │                   │  (Worker)  │                   │ Script  │
└─────────┘                   └────────────┘                   └─────────┘
     ↓                              ↓                               ↓
 User clicks                  Handles all                    Runs on web
 toolbar icon                 Chrome APIs                    pages, can
                              and storage                    modify DOM
```

### Key Files to Modify

| Task | File(s) |
|------|---------|
| Add new setting | `src/lib/storage.ts` → StorageSchema |
| Add new message type | `src/lib/messaging.ts` → MessageTypes |
| Handle new message | `src/background/index.ts` → createMessageHandler |
| Modify popup UI | `src/popup/Popup.tsx` |
| Modify options page | `src/options/Options.tsx` |
| Add page manipulation | `src/content/index.ts` |
| Change permissions | `manifest.json` → permissions |

## Common Tasks

### Adding a New Storage Key

1. Edit `src/lib/storage.ts`:
```typescript
export interface StorageSchema {
  settings: { ... };
  userData: { ... };
  // Add your new key:
  myFeature: {
    enabled: boolean;
    data: string[];
  };
}
```

2. Use it anywhere:
```typescript
import { getStorage, setStorage } from "@/lib/storage";

const myData = await getStorage("myFeature");
await setStorage("myFeature", { enabled: true, data: ["item1"] });
```

### Adding a New Message Type

1. Edit `src/lib/messaging.ts`:
```typescript
export interface MessageTypes {
  // ... existing types ...

  FETCH_DATA: {
    request: { url: string };
    response: { data: unknown; success: boolean };
  };
}
```

2. Add handler in `src/background/index.ts`:
```typescript
createMessageHandler({
  // ... existing handlers ...

  FETCH_DATA: async (payload) => {
    const response = await fetch(payload.url);
    const data = await response.json();
    return { data, success: true };
  },
});
```

3. Call from popup/content:
```typescript
import { sendToBackground } from "@/lib/messaging";

const result = await sendToBackground("FETCH_DATA", { url: "https://api.example.com" });
if (result.success) {
  console.log(result.data);
}
```

### Adding a New Permission

Edit `manifest.json`:
```json
{
  "permissions": [
    "storage",
    "activeTab",
    "scripting",
    "tabs",          // Add for full tab access
    "notifications", // Add for notifications
    "alarms"         // Add for scheduled tasks
  ]
}
```

### Adding Keyboard Shortcuts

Edit `manifest.json`:
```json
{
  "commands": {
    "_execute_action": {
      "suggested_key": {
        "default": "Ctrl+Shift+Y",
        "mac": "Command+Shift+Y"
      },
      "description": "Open extension popup"
    },
    "toggle-feature": {
      "suggested_key": {
        "default": "Ctrl+Shift+U"
      },
      "description": "Toggle feature"
    }
  }
}
```

Handle in background:
```typescript
chrome.commands.onCommand.addListener((command) => {
  if (command === "toggle-feature") {
    // Handle command
  }
});
```

### Adding Context Menu Items

In `src/background/index.ts`:
```typescript
chrome.runtime.onInstalled.addListener(() => {
  chrome.contextMenus.create({
    id: "my-action",
    title: "Do Something",
    contexts: ["selection", "page"],
  });
});

chrome.contextMenus.onClicked.addListener((info, tab) => {
  if (info.menuItemId === "my-action") {
    // Handle click
    // info.selectionText contains selected text
  }
});
```

### Injecting UI into Web Pages

In `src/content/index.ts`:
```typescript
function injectUI() {
  // Create shadow root to isolate styles
  const host = document.createElement("div");
  host.id = "my-extension-root";
  const shadow = host.attachShadow({ mode: "closed" });

  // Add your UI
  shadow.innerHTML = `
    <style>
      .container { /* styles isolated from page */ }
    </style>
    <div class="container">
      <button id="my-btn">Click me</button>
    </div>
  `;

  document.body.appendChild(host);

  // Add event listeners
  shadow.getElementById("my-btn")?.addEventListener("click", () => {
    // Handle click
  });
}
```

### Making API Calls

Create `src/lib/api.ts`:
```typescript
const API_BASE = "https://api.example.com";

export async function fetchData<T>(endpoint: string): Promise<T> {
  const response = await fetch(`${API_BASE}${endpoint}`);
  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }
  return response.json();
}
```

Note: API calls should generally be made from the background script to avoid CORS issues.

### Adding Notifications

```typescript
// Requires "notifications" permission
chrome.notifications.create({
  type: "basic",
  iconUrl: chrome.runtime.getURL("icons/icon-128.png"),
  title: "Notification Title",
  message: "Notification message",
});
```

### Adding Alarms (Scheduled Tasks)

```typescript
// Requires "alarms" permission

// Create alarm
chrome.alarms.create("my-alarm", {
  delayInMinutes: 1,
  periodInMinutes: 60, // Repeat every hour
});

// Handle alarm
chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === "my-alarm") {
    // Do scheduled task
  }
});
```

## Build Commands

```bash
npm run dev      # Development with HMR
npm run build    # Production build
npm run lint     # Run ESLint
npm run typecheck # TypeScript check
```

## Loading the Extension

1. Run `npm run dev` or `npm run build`
2. Open `chrome://extensions/`
3. Enable "Developer mode"
4. Click "Load unpacked"
5. Select the `dist` folder

## Common Patterns

### Check if Extension is Enabled
```typescript
const settings = await getStorage("settings");
if (!settings?.enabled) return;
```

### Send Message to All Tabs
```typescript
const tabs = await chrome.tabs.query({});
for (const tab of tabs) {
  if (tab.id) {
    try {
      await chrome.tabs.sendMessage(tab.id, { type: "UPDATE" });
    } catch {
      // Tab might not have content script
    }
  }
}
```

### Get Current Tab
```typescript
const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
```

### Execute Script in Tab
```typescript
// Requires "scripting" permission
await chrome.scripting.executeScript({
  target: { tabId: tab.id },
  func: () => {
    // This runs in the page context
    document.body.style.backgroundColor = "red";
  },
});
```

## Debugging

- **Background script**: Go to `chrome://extensions/`, click "Service Worker" link
- **Popup**: Right-click extension icon → Inspect popup
- **Content script**: Regular page DevTools, check console for `[Content Script]` logs
- **Storage**: DevTools → Application → Local Storage → chrome-extension://...

## File Size Limits

- Total extension: 10MB recommended
- Individual files: No hard limit, but keep reasonable
- Icons: Keep small, PNG format
